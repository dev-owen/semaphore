# 어떻게 동작하는가

## 신원 삽입

신원은 다음과 같은 정보들로 구성되어 있다.

1. 하나의 [EdDSA](https://en.wikipedia.org/wiki/EdDSA) 개인 키. 이건 이더리움 개인 키가 아니다.
2. 하나의 신원 널리파이어, 무작위 32바이트 값으로 이루어져 있다.
3. 하나의 신원 트랩도어, 무작위 32바이트 값으로 이루어져 있다.

신원 약속은 아래 값들의 페데르센 해시 값이다.

1. 신원의 개인 키와 관련이 되어 있는 공개 키.
2. 신원 널리파이어.
3. 신원 트랩도어.

신원을 등록하기 위하여, 사용자는 반드시 그들의 신원 약속을 세마포의 신원 트리에 입력해야 한다. 
이 과정은 세마포 컨트랙트의 `insertIdentity(uint256 _identityCommitment)` 함수를 호출하여 할 수 있다.
[API 레퍼런스](https://semaphore.appliedzkp.org/api.html) 에서 더 많은 정보를 얻을 수 있다.

## 신호 전송

신호를 전송하기 위해서, 사용자는 반드시 이 세마포 컨트랙트 함수를 불러주어야 한다.

```
broadcastSignal(
    bytes memory _signal,
    uint256[8] memory _proof,
    uint256 _root,
    uint256 _nullifiersHash,
    uint232 _externalNullifier
)
```

- `_signal`: 전송할 신호
- `_proof`: zk-SNARK 증명 (아래 참조)
- `_root`: 신원 트리의 루트, 여기서 사용자의 신원 약속은 마지막으로 삽입된 리프이다.
- `_nullifiersHash`: 외부 널리파이어의 독립적으로 파생된 해시 값으로, 사용자의 신원 널리파이어이며, 그리고 그들의 신원 약속에 머클 경로 인덱스이다. 이는 사용자가 같은 외부 널리파이어로 두 번 이상 신호를 전송할 수 없도록 보장한다. 
- `_externalNullifier`: 신호가 전송될 때 외부 널리파이어

zk-SNARK 증명은 반드시 세마포의 zk-SNARK 회로에 의해 만들어진 다음과 같은 제약사항들을 충족해야 한다.

### zk-SNARK 회로

이 [세마포 회로](https://github.com/appliedzkp/semaphore/blob/master/circuits/circom/semaphore-base.circom) 는 아래의 사항들을 증명하는데 도움을 준다.

### 머클 트리에 존재하는 신원 약속

**개인 입력값들:**

- `identity_pk`: 사용자의 EdDSA 공개 키
- `identity_nullifier`: 사용자가 가져야 하는 무작위의 32바이트 값
- `identity_trapdoor`: 사용자가 가져야 하는 무작위의 32바이트 값
- `identity_path_elements`: 사용자의 신원 약속을 향한 머클 경로 값
- `identity_path_index[n_levels]`: 시용자 신원 약속의 머클 경로에 일치하는 트리 레벨의 방향 (왼쪽/오른쪽)

**공개 입력값들:**

- `root`: 신원 트리의 머클 루트

**절차:**

이 회로는 공개 키, 신원 널리파이어, 신원 트랩도어를 해싱하여 **신원 약속**을 생성한다. 그리고 나서 머클 루트와 신원 약속으로부터 머클 증명을 검증한다.

### 신호는 오직 한 번만 전송됨

**개인 입력값들:**

- `identity_nullifier`: 위와 동일
- `identity_path_index`: 위와 동일

**공개 입력값들:**

- `external_nullifier`: 29바이트 외부 널리파이어 - 위와 동일
- `nullifiers_hash`: 신원 널리파이어, 외부 널리파이어, 그리고 머클 경로 인덱스의 해시 값 (`identity_path_index`)

**절차:**

이 회로는 주어진 신원 널리파이어, 외부 널리파이어, 그리고 머클 경로 인덱스를 해싱하고, 이 값이 주어진 널리파이어 해시와 일치하는지 체크한다. 추가적으로 이 스마트 컨트랙트는 이전에 이 널리파이어 해시 값을 본 적이 없음을 보장한다. 이러한 방법으로 이중 신호는 불가능하다.

### 이 신호는 증명을 생성한 사용자에 의해 전송됨.

**개인 입력값들:**

- `identity_pk`: 위와 동일
- `auth_sig_r`: 신호의 서명 중 `r` 값 
- `auth_sig_s`: 신호의 서명 중 `s` 값

**공개 입력값들:**

- `signal_hash`: 신호의 해시 값
- `external_nullifier`: 29바이트 외부 널리파이어 - 위와 동일

**절차:**

이 회로는 신호 해시와 외부 널리파이어를 해싱하며, 이 결과값을 주어진 공개 키와 서명에 대하여 검증한다. 이는 신호의 진위 여부를 검증하고 클라이언트 사이드에서 발생하는 공격을 예방할 수 있다.

## 암호학적 요소

세마포는 MiMC를 머클 트리를 위해 사용하고, 신원 약속을 위해서는 페데르센 약속을 사용하며, 널리파이어 해시를 위해서는 Blake2를 사용하고, 서명을 위해서는 EdDSA를 사용한다.

MiMC는 비교적 새로운 해시 함수이다. 우리는 [Albrecht et al](https://eprint.iacr.org/2016/492.pdf) 이 권장하는 MiMC 설계를 사용하며, 여기에는 MiMC를 뚫으면 상을 주기도 하는데 [http://mimchash.org](http://mimchash.org) 아직 아무도 뚫지 못했다. 

우리는 또한 어떤 버전의 세마포를 동작시키는데, 이 버전은 머클 트리를 위해 포세이돈 해시 함수를 사용하며 EdDSA 서명 검증을 사용한다. 이는 MiMC보다 더 나은 보안을 제공할 것이며, 신원 입력 시 사용하는 가스를 20% 정도 절약할 수 있고, 검증 시간을 절반 가까이 줄일 수 있있다. 그러나, 포세이돈 관련 회로와 EVM 바이트코드 생성기는 아직 감사를 거치지 않았기에, 주의해서 사용해야 한다. 사용하기 위해서는 이 레포지토리의 `feat/poseidon` 브랜치를 사용하라. 
